// components/HistoryPanel.tsx
import React, { useEffect, useState } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Trash2, Music, ArrowRight, Share2, X, Loader2, Download } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/supabase/supabaseClient';
import { useAuth } from '@/contexts/AuthContext';
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { jsPDF } from 'jspdf';
import { Document, Packer, Paragraph, TextRun } from 'docx';

// --- Types ---
type HistoryEntry = {
  id: number;
  type: 'semitone' | 'scale';
  originalNotes: string[];
  transposedNotes: string[];
  semitones: number;
  fromScale?: string;
  toScale?: string;
  timestamp: string;
};

const formatDate = (timestamp: string) =>
  new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  }).format(new Date(timestamp));

const HistoryPanel: React.FC = () => {
  const { user } = useAuth();
  const { toast } = useToast();
  const [history, setHistory] = useState<HistoryEntry[]>([]);
  const [loading, setLoading] = useState(true);
  const [clearDialogOpen, setClearDialogOpen] = useState(false);
  const [deletingId, setDeletingId] = useState<number | null>(null);

  useEffect(() => {
    if (!user?.email) return;

    const fetchHistory = async () => {
      setLoading(true);
      const { data, error } = await supabase
        .from('transposition_history')
        .select('*')
        .eq('user_email', user.email)
        .order('created_at', { ascending: false });

      if (error) {
        toast({ title: 'Error loading history', description: error.message, variant: 'destructive' });
      } else {
        const parsed = (data || []).map((entry): HistoryEntry => ({
          id: entry.id,
          type: entry.type,
          originalNotes: typeof entry.original_formatted === 'string' ? entry.original_formatted.split('\n') : [],
          transposedNotes: typeof entry.transposed_formatted === 'string' ? entry.transposed_formatted.split('\n') : [],
          semitones: entry.semitones,
          fromScale: entry.from_scale,
          toScale: entry.to_scale,
          timestamp: entry.created_at,
        }));
        setHistory(parsed);
      }
      setLoading(false);
    };

    fetchHistory();
  }, [user?.email]);

  const generatePDF = (entry: HistoryEntry) => {
    const doc = new jsPDF();
    let y = 20;

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(14);
    doc.text('Transposition Export', 20, y);
    y += 10;

    doc.setFontSize(10);
    doc.text(`Generated: ${formatDate(entry.timestamp)}`, 20, y);
    y += 10;

    if (entry.type === 'scale') {
      doc.text(`Scale: ${entry.fromScale} → ${entry.toScale}`, 20, y);
    } else {
      doc.text(`Semitones: ${entry.semitones}`, 20, y);
    }
    y += 15;

    doc.setFont('courier', 'normal');
    doc.setFontSize(12);
    doc.text('Original Notes:', 20, y);
    y += 8;
    doc.text(entry.originalNotes.join('\n'), 20, y);
    y += entry.originalNotes.length * 7 + 8;
    doc.text('Transposed Notes:', 20, y);
    y += 8;
    doc.text(entry.transposedNotes.join('\n'), 20, y);

    y += entry.transposedNotes.length * 7 + 10;
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(14);
    doc.text('Generated by Notes Transposer', 20, y);

    return doc.output('blob');
  };

  const generateDOCX = (entry: HistoryEntry) => {
    const doc = new Document({
      sections: [
        {
          children: [
            new Paragraph({ children: [new TextRun({ text: 'Transposition Export', bold: true, size: 28 })] }),
            new Paragraph({ text: '' }),
            new Paragraph({ children: [new TextRun({ text: `Generated: ${formatDate(entry.timestamp)}` })] }),
            new Paragraph({
              children: [
                new TextRun({
                  text:
                    entry.type === 'scale'
                      ? `Scale: ${entry.fromScale} → ${entry.toScale}`
                      : `Semitones: ${entry.semitones}`,
                }),
              ],
            }),
            new Paragraph({ text: '' }),
            new Paragraph({ children: [new TextRun({ text: 'Original Notes:', bold: true })] }),
            ...entry.originalNotes.map(
              (line) => new Paragraph({ children: [new TextRun({ text: line, font: 'Courier New' })] })
            ),
            new Paragraph({ text: '' }),
            new Paragraph({ children: [new TextRun({ text: 'Transposed Notes:', bold: true })] }),
            ...entry.transposedNotes.map(
              (line) => new Paragraph({ children: [new TextRun({ text: line, font: 'Courier New' })] })
            ),
            new Paragraph({ text: '' }),
            new Paragraph({ children: [new TextRun({ text: 'Generated by Notes Transposer', bold: true })] }),
          ],
        },
      ],
    });
    return Packer.toBlob(doc);
  };

  const confirmDelete = async (id: number) => {
    setDeletingId(id);
    const { error } = await supabase.from('transposition_history').delete().eq('id', id);
    if (error) {
      toast({ title: 'Delete failed', description: error.message, variant: 'destructive' });
    } else {
      toast({ title: 'Entry deleted' });
      setHistory(history.filter((h) => h.id !== id));
    }
    setDeletingId(null);
  };

  const confirmDeleteAll = async () => {
    const { error } = await supabase.from('transposition_history').delete().eq('user_email', user?.email);
    if (error) {
      toast({ title: 'Delete failed', description: error.message, variant: 'destructive' });
    } else {
      toast({ title: 'All history deleted' });
      setHistory([]);
    }
    setClearDialogOpen(false);
  };

  return (
    <div className="p-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-2xl font-bold text-white">Transposition History</h2>
        {history.length > 0 && (
          <Button variant="destructive" size="sm" onClick={() => setClearDialogOpen(true)}>
            <Trash2 className="h-4 w-4 mr-2" /> Clear All
          </Button>
        )}
      </div>

      {loading ? (
        <p className="text-white">Loading...</p>
      ) : history.length === 0 ? (
        <p className="text-slate-400">No history found.</p>
      ) : (
        history.map((entry) => (
          <Card key={entry.id} className="mb-6 relative">
            <CardContent className="p-4">
              <div className="mb-4 text-sm text-slate-300">{formatDate(entry.timestamp)}</div>
              <div className="mb-2 font-semibold text-white">
                {entry.type === 'scale'
                  ? `Scale: ${entry.fromScale} → ${entry.toScale}`
                  : `Semitones: ${entry.semitones}`}
              </div>
              <div className="flex gap-4">
                <div className="w-1/2">
                  <h4 className="text-white mb-1">Original Notes</h4>
                  <pre className="bg-gray-900 text-white p-2 rounded text-sm whitespace-pre-wrap font-mono">
                    {entry.originalNotes.join('\n')}
                  </pre>
                </div>
                <div className="w-1/2">
                  <h4 className="text-white mb-1">Transposed Notes</h4>
                  <pre className="bg-gray-900 text-white p-2 rounded text-sm whitespace-pre-wrap font-mono">
                    {entry.transposedNotes.join('\n')}
                  </pre>
                </div>
              </div>
              <div className="mt-4 flex gap-2">
                <Button
                  variant="outline"
                  onClick={async () => {
                    const blob = generatePDF(entry);
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `transposition-${entry.id}.pdf`;
                    a.click();
                  }}
                >
                  Export PDF
                </Button>
                <Button
                  variant="outline"
                  onClick={async () => {
                    const blob = await generateDOCX(entry);
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `transposition-${entry.id}.docx`;
                    a.click();
                  }}
                >
                  Export Word
                </Button>
              </div>
              <Button
                variant="destructive"
                size="icon"
                className="absolute top-2 right-2"
                disabled={deletingId === entry.id}
                onClick={() => confirmDelete(entry.id)}
              >
                {deletingId === entry.id ? <Loader2 className="h-4 w-4 animate-spin" /> : <Trash2 className="h-4 w-4" />}
              </Button>
            </CardContent>
          </Card>
        ))
      )}

      <Dialog open={clearDialogOpen} onOpenChange={setClearDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Clear All History</DialogTitle>
          </DialogHeader>
          <p>Are you sure you want to delete all transposition history? This action cannot be undone.</p>
          <DialogFooter>
            <Button variant="outline" onClick={() => setClearDialogOpen(false)}>Cancel</Button>
            <Button variant="destructive" onClick={confirmDeleteAll}>Delete All</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default HistoryPanel;
